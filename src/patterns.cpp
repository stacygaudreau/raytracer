#include "raytracer/patterns.h"

namespace rt
{
////////////////////////////////////////////////////////////////////////////////////////////////////
// Pattern
////////////////////////////////////////////////////////////////////////////////////////////////////
Pattern::Pattern(Colour a, Colour b)
:   a(a),
    b(b)
{
    setTransform(TransformationMatrix::identity());
}

Colour Pattern::colourAtShape(Tuple pShape)
{
    // 1. convert shape space point to pattern space
    const auto pPattern = inverseTransform * pShape;
    // 2. find the colour at the point in pattern space
    return colourAt(pPattern);
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// StripedPattern
////////////////////////////////////////////////////////////////////////////////////////////////////
Colour StripedPattern::colourAt(Tuple point)
{
    return static_cast<int>(floor(point.x)) % 2 == 0 ? a : b;
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// GradientPattern
////////////////////////////////////////////////////////////////////////////////////////////////////
Colour GradientPattern::colourAt(Tuple point)
{
    // basic linear interpolation btwn 2 colours, based on x component of vector
    return a + (b - a) * (point.x - floor(point.x));
}


////////////////////////////////////////////////////////////////////////////////////////////////////
// RingPattern
////////////////////////////////////////////////////////////////////////////////////////////////////
Colour RingPattern::colourAt(Tuple point)
{
    const int posXY = floor(static_cast<double>(sqrt(point.x*point.x + point.z+point.z)));
    return posXY % 2 == 0 ? a : b;
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// RingPattern
////////////////////////////////////////////////////////////////////////////////////////////////////
Colour CheckersPattern::colourAt(Tuple point)
{
    const int toFloor = static_cast<int>(floor(point.x))
                        + static_cast<int>(floor(point.y))
                        + static_cast<int>(floor(point.z));
    return toFloor % 2 == 0 ? a : b;
}
}
